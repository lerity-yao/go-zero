package cron

import (
	"fmt"
	"os"
	"path"
	"strings"

	"github.com/lerity-yao/go-zero/tools/cztctl/api/gogen"
	"github.com/lerity-yao/go-zero/tools/cztctl/api/spec"
	"github.com/lerity-yao/go-zero/tools/cztctl/config"
	"github.com/lerity-yao/go-zero/tools/cztctl/internal/version"
	"github.com/lerity-yao/go-zero/tools/cztctl/util/format"
	"github.com/lerity-yao/go-zero/tools/cztctl/util/pathx"
	"github.com/lerity-yao/go-zero/tools/cztctl/vars"
	"github.com/zeromicro/go-zero/core/collection"
)

const (
	workerFilename = "workers"
	workerTemplate = `// Code generated by cztctl. DO NOT EDIT.
// cztctl {{.version}}

package handler

import (
	{{.ImportPackages}}
)

func RegisterHandlers(server *service.ServiceGroup, serverCtx *svc.ServiceContext) {
	{{.WorkerAdditions}}
}
`
)

func genWorker(dir, rootPkg string, cfg *config.Config, api *spec.ApiSpec) error {

	workerFileName, err := format.FileNamingFormat(cfg.NamingFormat, workerFilename)
	if err != nil {
		return err
	}

	workerFileName = workerFileName + ".go"
	filename := path.Join(dir, handlerDir, workerFileName)
	_ = os.Remove(filename)

	workerAdditionNames := getWorkerAdditions(api)

	imports := workerImports(api, rootPkg)

	return gogen.GenFile(gogen.FileGenConfig{
		Dir:             dir,
		Subdir:          handlerDir,
		Filename:        workerFileName,
		TemplateName:    "workerTemplate",
		Category:        category,
		TemplateFile:    workerTemplateFile,
		BuiltinTemplate: workerTemplate,
		Data: map[string]any{
			"ImportPackages":  strings.Join(imports, "\n"),
			"WorkerAdditions": strings.Join(workerAdditionNames, "\n"),
			"version":         version.BuildVersion,
		},
	})
}

func workerImports(api *spec.ApiSpec, parentPkg string) []string {
	importNames := collection.NewSet[string]()
	importNames.Add(fmt.Sprintf("\"%s%s\"", vars.ProjectOpenSourceURL, "/core/service"),
		fmt.Sprintf("\"%s\"", pathx.JoinPackages(parentPkg, contextDir)))

	for _, g := range api.Service.Groups {
		for _, h := range g.Routes {
			handlerPath := getHandlerFolderPath(g, h)
			pkgName := handlerPath[strings.LastIndex(handlerPath, "/")+1:]
			importNames.Add(fmt.Sprintf("\"%s\"", pathx.JoinPackages(parentPkg, handlerDir, pkgName)))
		}
	}

	return importNames.Keys()
}

func getWorkerAdditions(api *spec.ApiSpec) []string {
	workerAdditionNames := collection.NewSet[string]()
	for _, g := range api.Service.Groups {
		for _, h := range g.Routes {
			pattern, _ := getHandlerBaseName(h)
			handler := getHandlerName(h)
			handlerPath := getHandlerFolderPath(g, h)
			pkgName := handlerPath[strings.LastIndex(handlerPath, "/")+1:]
			if handlerPath != handlerDir {
				handler = strings.Title(handler)
			}

			l := fmt.Sprintf("serverCtx.CronServer.Add(\"%s\", %s.%s(serverCtx))",
				pattern, pkgName, handler)
			workerAdditionNames.Add(l)
			cronDoc := strings.TrimSuffix(strings.TrimPrefix(h.AtDoc.Text, "\""), "\"")
			if strings.HasPrefix(cronDoc, "cron:") {
				cronSpec := strings.TrimPrefix(cronDoc, "cron: ")
				routePath := h.Path
				if strings.HasPrefix(routePath, "/cron") && strings.HasSuffix(routePath, fmt.Sprintf(".%s", pattern)) {
					ll := fmt.Sprintf("serverCtx.CronServer.CronAdd(\"%s\", \"%s\")", cronSpec, pattern)
					workerAdditionNames.Add(ll)
				}
			}
		}
	}
	workerAdditionNames.Add("server.Add(serverCtx.CronServer)")

	return workerAdditionNames.Keys()
}
